import{_ as e,c as t,o as i,a2 as a}from"./chunks/framework.84TDCN6B.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Knowledge Fragments/webrtc.md","filePath":"Knowledge Fragments/webrtc.md"}'),l={name:"Knowledge Fragments/webrtc.md"},s=a('<p>web real-time communication，网页实时通信。主要用于视频通话。</p><p>RTCPeerConnection确保打开线路，打开媒体通道。</p><p>mediaDevices.getUserMedia处理摄像头、话筒、视频和声音。</p><p>RTCDataChannel数据通道的通信。</p><p>SDP，Session Description Protocol会话描述协议，用于在p2p协商时共享彼此的IP地址和端口，以及双方都能使用的音频和视频的编码信息。</p><p>ICE，穿透Nat建立点对点通信的方法，其中会用到STUN和TURN服务器。本地主机将包发送到stun服务器。stun服务器将请求的全球IP地址和端口返回给nat内部的主机。通过这两个步骤，就可以确保通信线路，并获取可以从外部进行通信的地址和端口。stun对于穿透nat必不可少。</p><h2 id="restfulapi" tabindex="-1">restfulapi <a class="header-anchor" href="#restfulapi" aria-label="Permalink to &quot;restfulapi&quot;">​</a></h2><p>rest，respresentatial state transfer 描述性状态性迁移。</p><ul><li>像GET/users/用户ID/respositories这样，通过向路径发送方法来获取服务</li><li>通过状态码通知客户端是否成功</li><li>URL用来表示资源的位置，作为服务的页面，它非常重要。</li><li>有时也会根据需要发送get参数和post主题等附加信息</li><li>服务器返回值大多是JSON和xml之类的结构化文本，或者图像数据等。</li></ul><p>从客户端角度看：</p><ul><li>URL是表示资源层的路径，仅由名词构成</li><li>通过向资源发送http方法来获取？更新和添加等操作</li><li>通过查看状态码判断请求是否被正确处理</li><li>无论调用多少次get方法，都不会改变状态</li><li>客户端不管理状态，每次请求都是独立执行的</li><li>不存在事务</li></ul><h2 id="web应用程序的动作模式" tabindex="-1">web应用程序的动作模式 <a class="header-anchor" href="#web应用程序的动作模式" aria-label="Permalink to &quot;web应用程序的动作模式&quot;">​</a></h2><ul><li>第一代：服务端渲染</li><li>第二代：ajax</li><li>第三代：单页面应用：返回几乎空的HTML和大量的js代码，让浏览器自己根据js生成页面。这其中会用到虚拟dom，是一种描述dom结构和表现的方式。</li><li>服务端渲染：单页面应用需要下载大量的js代码，下载完之前页面为空空白。服务器渲染是在服务器端动态生成HTML直接返回给客户端。</li></ul>',13),r=[s];function o(n,p,c,_,d,u){return i(),t("div",null,r)}const f=e(l,[["render",o]]);export{h as __pageData,f as default};
