import{_ as s,c as a,o as p,a2 as e}from"./chunks/framework.84TDCN6B.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Python/元组.md","filePath":"Python/元组.md"}'),n={name:"Python/元组.md"},t=e(`<p>元组与列表非常类似，只不过元组是不可变的。元组有如下两大特点。</p><ul><li>任意对象的有序集合： 与字符串和列表类似，元组是一个基于位置的有序对象集合。</li><li>通过偏移量存取： 与字符串、列表一样，元组通过偏移量读写。也支持所有基于偏移量的操作，例如索引和分片。</li><li>不可变： 这是元组与列表最大的区别，列表中的元素可以改变，而元组中的元素不能改变。</li></ul><p>如下示例给出了元组的常见定义方式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>turple1 = ()  #  一个空元组</span></span>
<span class="line"><span>turple2 = (1) # 单个元素的元组</span></span>
<span class="line"><span>turple3 = (1, 2.5, &#39;hello&#39;) # 三个元素的元组</span></span></code></pre></div><p><strong>元组的不可变性</strong></p><p>为什么有了列表还要使用元组？关键就在于元组的不可变性，我们可以修改列表的元素，但是无法对元组的元素。例如，如果要更改元组中某个位置的值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>turple8 = (1,2,3,4)</span></span>
<span class="line"><span># 期望修改第1个元素</span></span>
<span class="line"><span>turple8[0] = 10</span></span></code></pre></div><p>解释器会报出如下错误：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>TypeError: &#39;tuple&#39; object does not support item assignment</span></span>
<span class="line"><span>语法错误： 元组对象不支持元素赋值</span></span></code></pre></div><p><strong>通过可迭代对象得到新元组</strong></p><p>turple()函数接受一个可迭代对象，例如字符串或列表，从而得到一个新元组。例如，通过字符串得到元组：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>turple4 = turple(&quot;hello&quot;)</span></span></code></pre></div><p>通过列表得到元组：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>list = [1,2,3]</span></span>
<span class="line"><span>turple5 = turple(list)</span></span></code></pre></div><p><strong>元组的索引和分片</strong></p><p>通过中括号和从0开始的索引得到元组的元素：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>turple6 = (1, 2.5, &#39;hello&#39;)</span></span>
<span class="line"><span>print(turple6[2]) # &#39;hello&#39;: 读取第3个位置</span></span></code></pre></div><p>可以对元组进行分片得到新元组，<code>[n:m]</code>表示从第n+1个元素到第m个元素，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>turple7= (1,2,3,4,5,6,7)</span></span>
<span class="line"><span>turple8 = turple7[3:6]  # (4,5,6) ：从第4个元素到第6个元素</span></span></code></pre></div><p><strong>元组的拖尾逗号</strong></p><p>元组的最后一个元素后面可以选择性的添加一个逗号，这并不会影响元素个数，这种逗号叫做“拖尾逗号”，在有些编辑场景下很实用。如下两种写法是等价的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>turple1 = (1,2,3,4)</span></span>
<span class="line"><span>turple2 = (1,2,3,4,)</span></span></code></pre></div>`,22),l=[t];function i(o,c,d,r,h,u){return p(),a("div",null,l)}const b=s(n,[["render",i]]);export{v as __pageData,b as default};
