import{_ as a,c as s,o as e,a2 as t}from"./chunks/framework.84TDCN6B.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Node.js/zx.js使用.md","filePath":"Node.js/zx.js使用.md"}'),n={name:"Node.js/zx.js使用.md"},o=t(`<h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p>使用如下命令全局安装zx，以便在任何文件夹内使用：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>npm i -g zx</span></span></code></pre></div><h2 id="第一个示例" tabindex="-1">第一个示例 <a class="header-anchor" href="#第一个示例" aria-label="Permalink to &quot;第一个示例&quot;">​</a></h2><p>新建一个文件例如ls.mjs。编辑内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>import { $ } from &quot;zx&quot;;</span></span>
<span class="line"><span>$.verbose = false;</span></span>
<span class="line"><span>const output = (await $\`ls\`).stdout.trim();</span></span>
<span class="line"><span>console.log(output);</span></span></code></pre></div><p>然后运行： zx ls.mjs</p><h2 id="代码解释" tabindex="-1">代码解释 <a class="header-anchor" href="#代码解释" aria-label="Permalink to &quot;代码解释&quot;">​</a></h2><p>$.verbose默认为true，会输出被调用的shell命令本身，我们这里设置为false。</p><p>$符号的作用是调用shell命令，大多数命令的调用都是异步的，所以加上await。</p><p>有些命令是用于执行操作，没有输出，例如mkdir、rename等。而有些命令我们是需要得到其输出结果的，例如ls、cat等。对于需要得到结果的命令，使用stdout（）函数以字符串的形式取回命令的输出结果，这相当于shell的重定向操作。最后，由于命令输出结果可能会在最后一行包含空白行，所以我们使用trim（）方法去掉字符串的空白行。</p>`,11),p=[o];function l(i,c,r,d,h,u){return e(),s("div",null,p)}const b=a(n,[["render",l]]);export{m as __pageData,b as default};
