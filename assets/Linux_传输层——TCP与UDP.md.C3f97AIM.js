import{_ as e,c as i,o as a,a2 as l}from"./chunks/framework.84TDCN6B.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Linux/传输层——TCP与UDP.md","filePath":"Linux/传输层——TCP与UDP.md"}'),p={name:"Linux/传输层——TCP与UDP.md"},t=l('<h2 id="端口" tabindex="-1">端口 <a class="header-anchor" href="#端口" aria-label="Permalink to &quot;端口&quot;">​</a></h2><p>我们都知道IP数据包的传送的起点和终点是IP地址，那么达到后具体应该连接到哪里去呢？一台主机可以部署多个服务，那么是连接到WWW服务器，还是FTP服务呢？这就需要通过端口区分不同的服务，一个特定的服务由两部分组成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>地址:端口</span></span></code></pre></div><p>地址可以是IP地址，也可以是主机名称。</p><p>端口的取值范围为0-65535，不过，0-1023已经分给了常用的应用程序，因此一般的取值范围是1024~65535。</p><p>常见的服务与端口的对应如下：</p><ul><li>20 FTP</li><li>22 SSH 安全远程连接服务</li><li>25 SMTP 简单邮件传递协议</li><li>80 HTTP，超文本传输协议服务</li><li>110 POP3 邮件接收协议</li><li>443 HTTPS 安全加密的HTTP服务</li><li>3306 MySQL 默认端口号</li></ul><h2 id="tcp-三次握手" tabindex="-1">TCP 三次握手 <a class="header-anchor" href="#tcp-三次握手" aria-label="Permalink to &quot;TCP 三次握手&quot;">​</a></h2><p><img src="https://pics4.baidu.com/feed/1ad5ad6eddc451da91dfe64756fd5b6bd016327a.jpeg@f_auto?token=6a788b3425a128f386466dad924ccf99" alt="TCP的三次握手"></p><p>在TCP的连接模式中，在建立连接之前都必须通过三个确认的动作，所以这种连接方式也被称为三次握手，大致分为四个阶段。</p><ul><li><p>第一阶段，数据包发起 当可以的想要对服务器端连接时，就必须要送出一个要求连接的数据包，此时客户端必须随机取用一个大于1024的空闲的端口来作为程序沟通的接口。然后再TCP的报头当中，必须要带有SYN的主动连接（SYN=1），并且记下发出连接数据包给服务器端的序号（Sequence number = 10001）。</p></li><li><p>第二阶段，数据包接收与确认数据包发送 当服务器接收到这个数据包，并且确定要接收这个数据包后，就会开始制作一个同时带有SYN=1，ACK=1 的数据包，其中那个Acknowledge的号码是要给Client端确认用的，所以该数字会比A步骤里面的Sequence号码多一号（ack=10001+1=10002），那服务器也必须确认客户端确实可以接收我们的数据包才行，所以也会发送出一个Sequence（seq=20001）给客户端，并且开始等待客户端与服务器端的回应。</p></li><li><p>第三阶段，回送确认数据包 当客户端收到来自服务器端的ACK数字（10002）后，就能确认之前那个请求连接的数据包被正确接收了，接下来如果客户端也同意与服务器建立连接时，就会再次发送一个确认数据包（ACK=1）给服务器，即Acknowledge = 20001+1 = 20002.</p></li><li><p>第四阶段 取得最后确认 若一切都顺利，在服务器端收到带有ACK=1 且ack = 20002序号的数据包后，就能够建立起这次的连接了。</p></li></ul><p>举个通俗得了例子，好比两个人A和B在谈论事情之前打招呼：</p><ul><li>A说： B你听得到吗？</li><li>B说：我听得到，A你听得到吗？</li><li>A说：我也听得到</li></ul><p>可能有的人会有疑问，为什么B要再次询问一遍呢？B收到消息后直接建立连接不行吗？假设A说中文但听不懂英文，B说英文也可以听懂中文，这时候直接建立后A是听不懂的，必须要保证双方都能听懂对方说的话才行。</p><p>那为什么不来回更多次呢？理论上也是可以的，不过，为了节省资源，只需要双方都说一次，然后确认对方听懂了就够了。</p><p>总之，三次握手就是要确认两件事：</p><ul><li>服务端能有效识别客户端的信息</li><li>客户端能有效识别服务端的信息</li></ul><h2 id="tcp的四次挥手" tabindex="-1">TCP的四次挥手 <a class="header-anchor" href="#tcp的四次挥手" aria-label="Permalink to &quot;TCP的四次挥手&quot;">​</a></h2><p><img src="https://pics1.baidu.com/feed/c8177f3e6709c93d3b2db2957e3df1d1d0005486.jpeg@f_auto?token=d1003b5bd35811075409c512e0503094" alt="TCP的四次挥手"></p><p>TCP的四次挥手是为了结束已建立的连接，确保双方都能正确地关闭连接并释放资源。下面是四次挥手的过程：</p><ul><li><p>第一次挥手：客户端发送一个带有FIN（结束）标志的数据包，表示自己已经没有数据要发送了，请求关闭连接。</p></li><li><p>第二次挥手：服务器接收到客户端的结束请求后，会发送一个带有ACK（确认）标志的数据包作为响应，表示已收到客户端的结束请求。</p></li><li><p>第三次挥手：服务器发送一个带有FIN标志的数据包，表示自己也没有数据要发送了，请求关闭连接。</p></li><li><p>第四次挥手：客户端接收到服务器的结束请求后，会发送一个带有ACK标志的数据包作为确认，表示已收到服务器的结束请求。</p></li></ul><p>在关闭连接时，需要确保双方都完成了数据的传输和接收，以防止数据丢失或错误。如果只有三次挥手，可能会导致一些问题。</p><p>假设只有三次挥手，当客户端发送结束请求后，服务器收到后会发送确认，表示已收到客户端的结束请求。但是在此过程中，服务器可能还有未发送完的数据，如果直接关闭连接，那么这些数据就会丢失。因此，引入第三次挥手，服务器在发送结束请求前，先发送所有未发送完的数据，并等待客户端的确认。客户端接收到服务器的结束请求后，会确认并处理完未接收的数据，然后发送确认，表示自己已准备好关闭连接。</p><p>通过四次挥手，可以确保双方都能正确地结束连接，并处理未发送和未接收的数据，保证数据的完整性和可靠性。因此，关闭连接需要四次挥手。</p>',24),c=[t];function d(s,n,o,r,u,P){return a(),i("div",null,c)}const T=e(p,[["render",d]]);export{h as __pageData,T as default};
