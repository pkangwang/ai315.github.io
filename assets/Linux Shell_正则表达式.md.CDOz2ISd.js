import{_ as l,c as e,o,a2 as i}from"./chunks/framework.84TDCN6B.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Linux Shell/正则表达式.md","filePath":"Linux Shell/正则表达式.md"}'),c={name:"Linux Shell/正则表达式.md"},d=i('<p>正则表达式表示一种不确定模糊查找，例如匹配一个数字，匹配一个大写字符等。</p><p>正则表达式的符号和规则在很多语言和编辑器中有些通用的，有些不通用，主要看对正则表达式的支持程度。例如，有些语言可以使用<code>\\d</code>表示一个数字，但在sed中却不支持。</p><p>正则表达式分为两类，基础正则表达式和扩展正则表达式。基础正则表达式有着更广泛的通用性，因此我们以基础正则表达式为主。</p><p>需要注意的是，正则表达式的特殊字符与一般在命令行输入命令的通配符并不相同，例如，在通配符当中的<code>*</code>代表的是【0-无限多个字符】的意思，但是在正则表达式中，<code>*</code>则表示【重复前一个字符0到无穷多次】，不要搞混了。</p><h2 id="特殊字符" tabindex="-1">特殊字符 <a class="header-anchor" href="#特殊字符" aria-label="Permalink to &quot;特殊字符&quot;">​</a></h2><p>正则表达式使用一些特定字符表示位置、数量、数字、字母等作用，如果要匹配这些字符本身，需要在前面加上反斜杠以转义。这些字符是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.  *  [  ]  ^  $  {  }  \\  +  ?  |  (  ) /</span></span></code></pre></div><h2 id="正则符号及其作用" tabindex="-1">正则符号及其作用 <a class="header-anchor" href="#正则符号及其作用" aria-label="Permalink to &quot;正则符号及其作用&quot;">​</a></h2><p>正则符号大致分为以下几类。</p><ol><li>表示位置的：</li></ol><ul><li><code>^</code> 匹配行首</li><li><code>$</code> 匹配行尾</li><li><code>\\&lt;</code> 匹配单词词首,如&lt;abc匹配以abc开头的单词</li><li><code>\\&gt;</code> 匹配单词词尾,如abc&gt;匹配以abc结尾的单词</li><li><code>^$</code> 匹配空行</li><li><code>\\b</code> 匹配单词边界,如<code>\\broot\\b</code>匹配单词root</li><li><code>\\B</code> 匹配非单词边界,如root\\B匹配rooter而不匹配root</li></ul><ol start="2"><li>表示匹配次数的：</li></ol><ul><li><code>.</code> 字符占位，表示有且只有一个任意字符</li><li><code>*</code> 重复前一个字符0次及以上</li><li><code>+</code> 重复前一个字符1次及以上，需要开启扩展支持</li><li><code>?</code> 重复前一个字符0次到1次，需要开启扩展支持</li><li><code>^.*$</code> 匹配任意行</li><li><code>^..*$</code> 匹配有内容的行</li><li><code>\\{n,m\\}</code> 重复前一个字符n次到m次</li><li><code>\\{n,\\}</code> 重复前一个字符n次及以上</li><li><code>\\{n\\}</code> 重复前一个字符恰好n次</li></ul><ol start="3"><li>多个字符的逻辑或匹配：</li></ol><ul><li><code>[abc]</code> 多个单字符的逻辑或匹配，匹配其中的任意一个字符a或b或c。</li><li><code>[a-c]</code> 多个单字符的逻辑或匹配区间，匹配其中的任意一个字符a或b或c，可以连着写，例如<code>[a-zA-Z]</code>表示匹配任意一个字母。</li><li><code>[^abc]</code> 不匹配里面的任何一个字符 例如此例子表示不匹配a或b或c</li><li><code>g(la|oo)d</code> 字符串的逻辑或匹配，例如此例可以找出glad或good</li><li><code>str1|str2</code> 多个字符串的逻辑或匹配str1或str2。例如，前面的例子可以写成glad|good。</li></ul><ol start="4"><li>用反斜杠加一个字母表示一个或一类特定字符，包括：</li></ol><ul><li>\\d 匹配一个数字字符。等价于[0-9]。</li><li>\\D匹配一个非数字字符。等价于[^0-9]。</li><li>\\f 匹配一个换页符。等价于\\x0c和\\cL。</li><li>\\n 匹配一个换行符。等价于\\x0a和\\cJ。</li><li>\\r 匹配一个回车符。等价于\\x0d和\\cM。</li><li>\\s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。</li><li>\\S 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]。</li><li>\\t 匹配一个制表符。等价于\\x09和\\cI。</li><li><code>\\w</code> 匹配字母,数字和下划线,等同于<code>[A-Za-z0-9_]</code></li><li><code>\\W</code> 匹配非<code>\\w</code>的字符</li><li><code>\\s</code> 匹配空白字符</li><li><code>[[:alnum]]</code> 匹配英文大小写字符及数字，即0-9、A-Z、a-z</li><li><code>[[:alpha]]</code> 代表任何英文大小写字符, 即 A-Z a-z</li><li><code>[[:blank:]]</code> 代表空格键与Tab键</li><li><code>[[:cntrl:]]</code> 代表键盘上面的控制键</li><li><code>[[:digit:]]</code> 代表数字 即 0-9</li><li><code>[[:graph:]]</code> 除了空格键与Tab键以外的所有其它键</li><li><code>[[:lower:]]</code> 小写字母,即 a-z</li><li><code>[[:print:]]</code> 可以被打印出来的字符</li><li><code>[[:punct:]]</code> 标点符号</li><li><code>[[:upper:]]</code> 大写字母</li><li><code>[[:space:]]</code> 任何会产生空白的字符,包括空格\\Tab\\回车</li></ul><ol start="5"><li>字符组</li></ol><ul><li><code>\\(abc\\)\\{3\\}</code> 将括号里面的字符串当做一个字符，例如，此例表示匹配abcabcabc。</li></ul><h2 id="回溯引用" tabindex="-1">回溯引用 <a class="header-anchor" href="#回溯引用" aria-label="Permalink to &quot;回溯引用&quot;">​</a></h2><p>对于用括号包裹的子表达式，在查找和替换时可以使用<code>\\n</code>的形式进行回溯引用。</p><h2 id="查找替换选项" tabindex="-1">查找替换选项 <a class="header-anchor" href="#查找替换选项" aria-label="Permalink to &quot;查找替换选项&quot;">​</a></h2><ul><li>g 全局标志，意味着要找到所有匹配而不仅仅是第一个。</li><li>i 不区分大小写。</li><li>m 多行模式。对每一行进行匹配。这意味着<code>^</code>和<code>$</code>会匹配到每一行的开头和末尾，而不仅仅是文件的开头和结尾。</li></ul>',23),a=[d];function t(r,s,n,p,h,u){return o(),e("div",null,a)}const m=l(c,[["render",t]]);export{b as __pageData,m as default};
