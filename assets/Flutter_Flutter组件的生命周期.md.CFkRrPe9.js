import{_ as s,c as i,o as a,a2 as t}from"./chunks/framework.84TDCN6B.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Flutter/Flutter组件的生命周期.md","filePath":"Flutter/Flutter组件的生命周期.md"}'),e={name:"Flutter/Flutter组件的生命周期.md"},l=t(`<p>和界面状态有关的组件类主要有三类，即无状态组件StatelessWidget、有状态组件StateWidget和可继承组件InheritedWidget。</p><h2 id="无状态组件" tabindex="-1">无状态组件 <a class="header-anchor" href="#无状态组件" aria-label="Permalink to &quot;无状态组件&quot;">​</a></h2><p>无状态组件StatelessWidget顾名思义就是指的状态是不可变的，界面外观一直保持不变。它通过构建一组更具体地描述用户界面的其他组件来生成部分用户界面。无状态组件的生命周期非常简单，它能通过build()方法快速生成屏幕的界面，并且只渲染一次，因此在执行速度和效率方面比有状态组件更好。通常在3种情况下调用无状态组件的build()方法以构建屏幕外观：</p><ul><li>第一次将无状态组件插入层次树中</li><li>当组件的父类更改配置时</li><li>当依赖的InheritedWidget组件发生更改时。</li></ul><p>在设计组件时，结合实际情况，尽量使用无状态组件。</p><h2 id="有状态组件" tabindex="-1">有状态组件 <a class="header-anchor" href="#有状态组件" aria-label="Permalink to &quot;有状态组件&quot;">​</a></h2><p>有状态组件继承了StateWidget类，需要定义两个类：</p><ul><li>组件类，继承自StateWidget</li><li>状态类，继承自State</li></ul><p>定义有状态组件的通用语法如下：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Example</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> StateWidget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key})</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _ExampleState</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _ExampleState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ExampleState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> State</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  @override</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  # </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Widget</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BuildContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>有状态组件是指具有可变状态的组件，有状态组件中包含状态类。可以通过调用状态类中的state.setState()方法，对界面中的节点及以下的整个子树进行更新。</p><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><p>状态类对有状态组件实现内部逻辑和状态的管理。当组件构造时，可以同步地读取组件中的信息，并在组件的生命周期中通过State.setState对它进行改变。</p><ul><li><strong>initState()</strong>：初始化方法，State对象根据BuildContext上下文或组件执行一次性初始化操作。在组件重构过程中，State对象只会初始化一次。</li><li><strong>build()</strong>：当State对象初始化完成后，框架将调用build()方法。State对象可以多次调用build()方法以更改组件树中的内容，以使界面内容发生改变。</li><li><strong>reassemble()</strong>，热重载使被调用</li><li><strong>didUpdateWidget()</strong>：当组件配置更改时被调用。</li><li><strong>didChangeDependencies()</strong> 方法时，State对象重写此方法，当此状态对象的依赖项更改时调用，这时框架会调用build()方法，以使界面发生重构。</li><li><strong>deactivate()</strong>：组件被移除时被调用。</li></ul><h2 id="setstate" tabindex="-1">setState () <a class="header-anchor" href="#setstate" aria-label="Permalink to &quot;setState ()&quot;">​</a></h2><p>使界面发生改变的主要方法就是调用setState()，在状态类中，调用一次setState()就会触发build()的执行。</p><p>在状态类的定义中，使状态发生变化的三处关键代码是：</p><ul><li>定义变量</li><li>在build()方法中使用变量</li><li>在一些回调函数的函数体中执行setState()，例如按钮的onPressed()回调函数。</li><li>在setState()中修改变量的值。</li></ul>`,18),n=[l];function h(p,k,r,d,g,E){return a(),i("div",null,n)}const y=s(e,[["render",h]]);export{c as __pageData,y as default};
