import{_ as e,c as l,o as i,a2 as t}from"./chunks/framework.84TDCN6B.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Linux/RestfulAPI.md","filePath":"Linux/RestfulAPI.md"}'),a={name:"Linux/RestfulAPI.md"},s=t('<h2 id="restfulapi" tabindex="-1">restfulapi <a class="header-anchor" href="#restfulapi" aria-label="Permalink to &quot;restfulapi&quot;">​</a></h2><p>rest，respresentatial state transfer 描述性状态性迁移。</p><ul><li>像GET/users/用户ID/respositories这样，通过向路径发送方法来获取服务</li><li>通过状态码通知客户端是否成功</li><li>URL用来表示资源的位置，作为服务的页面，它非常重要。</li><li>有时也会根据需要发送get参数和post主题等附加信息</li><li>服务器返回值大多是JSON和xml之类的结构化文本，或者图像数据等。</li></ul><p>从客户端角度看：</p><ul><li>URL是表示资源层的路径，仅由名词构成</li><li>通过向资源发送http方法来获取？更新和添加等操作</li><li>通过查看状态码判断请求是否被正确处理</li><li>无论调用多少次get方法，都不会改变状态</li><li>客户端不管理状态，每次请求都是独立执行的</li><li>不存在事务</li></ul><h2 id="web应用程序的动作模式" tabindex="-1">web应用程序的动作模式 <a class="header-anchor" href="#web应用程序的动作模式" aria-label="Permalink to &quot;web应用程序的动作模式&quot;">​</a></h2><ul><li>第一代：服务端渲染</li><li>第二代：ajax</li><li>第三代：单页面应用：返回几乎空的HTML和大量的js代码，让浏览器自己根据js生成页面。这其中会用到虚拟dom，是一种描述dom结构和表现的方式。</li><li>服务端渲染：单页面应用需要下载大量的js代码，下载完之前页面为空空白。服务器渲染是在服务器端动态生成HTML直接返回给客户端。</li></ul>',7),r=[s];function o(n,u,_,c,p,d){return i(),l("div",null,r)}const m=e(a,[["render",o]]);export{h as __pageData,m as default};
