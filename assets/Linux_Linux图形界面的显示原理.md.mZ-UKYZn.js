import{_ as i,c as l,o as e,a2 as a}from"./chunks/framework.84TDCN6B.js";const X=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Linux/Linux图形界面的显示原理.md","filePath":"Linux/Linux图形界面的显示原理.md"}'),n={name:"Linux/Linux图形界面的显示原理.md"},r=a('<h2 id="x-window-system" tabindex="-1">X Window System <a class="header-anchor" href="#x-window-system" aria-label="Permalink to &quot;X Window System&quot;">​</a></h2><p>从英文字母看，X在W（Window）后面，所有称为X，有下一代窗口之意。在Unix-like上的图形用户接口（GUI）被称为X或X11。X11只是一个软件而不是操作系统。</p><p>X Window分为X Server和X Client两个组件。X Server管理硬件，X Client管理应用程序。</p><p>由于每个X Clinet是独立的，并不知道其它的X Clinet，这样就会造成GUI界面的显示冲突，所以使用X Window Manager进行管理。X Window Manger，也叫窗口管理器，是一个特殊的X Client，负责管理所有的应用程序GUI。著名的X Window Manager有GNOME、KDE。</p><p>随着技术的发展，X Window窗口管理系统正逐步被淘汰，而被新一代图形界面管理系统——Wayland取代。</p><p>X Window System使用C/S架构,服务端和客户端可以基于网络通信。</p><p>客户端(也就是各种软件)将绘图请求发给服务端,服务端操纵显卡或视频终端把位图图像绘制出来,并处理键盘鼠标的事件,发送给客户端.注意,和人交互的是服务端.</p><ul><li>服务端监听到显示器、鼠标、键盘事件，将事件信息（例如用户在哪个位置点了一下）发送给客户端，请求指示“此时应该怎么显示？”</li><li>客户端接收到该事件信息，计算出显示逻辑（例如在某个地方显示一个图形），将绘制指令发送给客户端。注意，客户端没有绘制能力，它只发送绘制指令。</li><li>服务端接收到绘制指令，然后调用图形API“画”出来（图形、文字等）。</li><li>窗口管理器协调各个客户端的堆叠等状态。</li></ul><p>为什么需要窗口管理器？因为多个客户端是层叠的，谁在前面谁在后面客户端自己是不知道的，只能在窗口管理器中汇总才能知道。</p><p>通俗点解释。</p><ul><li>服务端说： 用户在坐标(50,50)处点了一下，这种情况该怎么显示？</li><li>客户端说：这种情况应该在坐标（100，100）处画一个笑脸图形。</li><li>服务端说：收到！我马上派遣调用图形API在（100，100）出画一个笑脸图形。</li></ul><p>但这种情况只能同时显示一个gui程序。为了管理众多的窗口怎么在屏幕上显示,需要窗口管理器(Window manager).窗口管理器可以实现一个屏幕上显示多个X程序,实现调整程序大小,标题栏,最大化,最小化,关闭按钮,虚拟桌面这些功能.没有WM,一次只能运行一个GUI程序,而且分辨率锁死,显然很不符合使用习惯.</p><p>窗口管理器的例子：</p><ul><li>服务端对客户端A说： 我监听到用户在坐标(50,50)处点了一下，这种情况该怎么显示？</li><li>客户端A对窗口管理器说：我要在（50，50）处画一个笑脸。</li><li>服务端对客户端A说： 我监听到用户在坐标(80,150)处点了一下，这种情况该怎么显示？</li><li>客户端B对窗口管理器说：我要在（80，150）处写一段文本。</li><li>服务端对客户端C说：我监听到用户点击了全屏按钮，这种情况该怎么显示？</li><li>客户端C对窗口管理器说：用户让我全屏显示窗口，并且要在其它客户端的前面。</li><li>窗口管理器：你们的指令都收到了，我来汇总出一个总的绘制指令xxxxxxxx。</li><li>窗口管理器对服务端说：我的总绘制指令是xxxxxxx，你负责给我显示出来。</li><li>服务端：收到！我马上派遣驱动程序显示出来。</li></ul><h2 id="wayland" tabindex="-1">Wayland <a class="header-anchor" href="#wayland" aria-label="Permalink to &quot;Wayland&quot;">​</a></h2><p>Wayland将X中的Server和窗口管理器整合到一起作为服务端，称为合成器（Compositor），架构上只分了客户端和合成器两大部件。</p><ul><li>客户端（Wayland Client），直接计算各自界面的渲染缓冲数据，然后自行绘制，并通知server更新了哪个区域。</li><li>合成器（Wayland Compositor），汇总所有客户端的更新通知，实现各界面窗口“合成”，最后交给显示驱动绘图，呈现最终效果。</li></ul><p>client和server端都会发生绘制。client绘制本地的窗口内容，server端主要用于合成时渲染。两边都可独立选择用软件或者硬件渲染。</p><p>为什么需要通知server再次合成？因为多个客户端窗口一般是层叠的，谁在前面谁在后面客户端自己是不知道的，只有集中在server中处理层叠关系。</p><p>通俗解释：</p><ul><li>合成器对客户端A说： 我监听到用户在坐标(50,50)处点了一下</li><li>客户端A在（50，50）处直接调用图形API画了一个笑脸，然后对Server说 ：我现在通知你，左上角xx区域已经更新了。</li><li>合成器对客户端B说： 我监听到用户在坐标(80,150)处点了一下。</li><li>客户端B直接调用图形API在（80，150）处写一段文本，然后对Server说：我现在通知你你，区域yyyy已经被更新了。</li><li>合成器对客户端C说：我监听到用户点击了全屏按钮。</li><li>客户端C直接调用API重新绘制了全屏下的图形，然后对Server说：全屏区域已经更新了。</li><li>合成器说：你们的通知都收到了，我会汇总你们的更新，看看谁应该在前面显示谁应该被遮挡，然后派遣图形驱动重新合成一个最终的效果呈现给用户。</li></ul><p>总之，x Window的特点是，client是无法调用图形API，只能将指令发送给server，让server去调用图形API绘制。也就是说，x server成为了client和图形API的“传话筒”，但是为什么不让client与图形API直接通信呢？于是Wayland应运而生。Wayland先进的地方在于，每个client都可以自行调用图形API绘制自己的窗口，server汇总信息，调用图形API汇总最终的合成界面。</p><p>这里的图形API指的是OpenGL、Direct X、metal、vulkan，下面还有图形驱动程序，再下面就是显卡。Vulkan是一个高性能的图形API，Wayland插上Vulkan的翅膀一定会带来更大的性能提升。</p>',23),t=[r];function o(p,d,s,_,x,c){return e(),l("div",null,t)}const W=i(n,[["render",o]]);export{X as __pageData,W as default};
