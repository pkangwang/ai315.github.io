import{_ as a,c as s,o as e,a2 as i}from"./chunks/framework.84TDCN6B.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Linux Shell/非对称加密和SSH协议.md","filePath":"Linux Shell/非对称加密和SSH协议.md"}'),l={name:"Linux Shell/非对称加密和SSH协议.md"},p=i('<h2 id="加密算法的分类" tabindex="-1">加密算法的分类 <a class="header-anchor" href="#加密算法的分类" aria-label="Permalink to &quot;加密算法的分类&quot;">​</a></h2><ul><li>对称加密算法：在加密和解密时使用同一个密钥，这种算法不安全，几乎不再使用了。</li><li>非对称加密算法：通过密钥算法同时一对密钥：公钥和私钥，分别用于加密和解密。目前在各大安全协议中被使用。</li></ul><p>非对称加密算法主要包括：</p><ul><li>rsa：主流，ssh-keygen工具默认</li><li>dsa</li></ul><h2 id="非对称秘钥的文件位置和内容" tabindex="-1">非对称秘钥的文件位置和内容 <a class="header-anchor" href="#非对称秘钥的文件位置和内容" aria-label="Permalink to &quot;非对称秘钥的文件位置和内容&quot;">​</a></h2><p>公钥和私钥都是一个文本文件，里面存放着一定长度的字符串，默认放在~/.ssh目录。</p><p>公钥私钥是成对生成、成对存在的，其名字也应该对应。假设是用rsa算法生成的一对公私钥，那么其名称默认是：</p><ul><li>~/.ssh/id_rsa 私钥</li><li>~/.ssh/id_rsa.pub 公钥</li></ul><p>当然，名称也可以自己取一个有辨识度的名字。</p><p>公钥顾名思义就是可以公开的，A和B首先把自己的公钥发给对方，然后把对方的的公钥追加进自己的~/.ssh/known_hosts文件中，这个文件存放的是从网络上接收到的各个主机的公钥，每条信息占一行，每一行的格式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>主机  加密算法   公钥字符串==</span></span></code></pre></div><h2 id="非对称加密传递信息" tabindex="-1">非对称加密传递信息 <a class="header-anchor" href="#非对称加密传递信息" aria-label="Permalink to &quot;非对称加密传递信息&quot;">​</a></h2><p>假设网络上的两台主机A和B需要传递信息。那么A和B首先生成自己的私钥和公钥。</p><p>现在A要跟B发送信息，A就使用B的公钥将原始信息加密，得到一条加密信息通过网络发送给B，由于原始信息是通过B的公钥加密的，那么加密信息只能通过B的私钥解密，A的公钥私钥、B的公钥、其它网络上任何人的公钥私钥都无法解密这条加密信息。B收到后通过自己的私钥成功界面，就看到了原始信息。在这个过程中，哪怕加密信息被别人截取到了，也无法解密。</p><p>总而言之，公钥是用来加密的，私钥是用来解密的。要给对方发送消息，就用对方的公钥加密，等信息到达对方主机后，对方就可以解密了。</p><p>非对称秘钥有几个特点：</p><ul><li>全局唯一：不同的人在同一时间，或同一个人在不同时间生成公钥私钥一定是不同的。也就是说，每个人的私钥一定是不同的，这确保了身份的准确性。</li><li>一对一：公钥和私钥是成对生成的，用公钥加密的信息只能通过对应的私钥解密，其它私钥绝对不可能解密。</li><li>确定性：用对应的私钥一定能解密，不用对应的私钥一定不能解密。</li></ul><h2 id="数字证书和数字签名" tabindex="-1">数字证书和数字签名 <a class="header-anchor" href="#数字证书和数字签名" aria-label="Permalink to &quot;数字证书和数字签名&quot;">​</a></h2><p>现在，又有一个问题，如何保证这条加密信息是由a发出来的？换句话说，C也可以生成一对公私钥，发送给B，然后对B说：“我是A，这是我的公钥”。</p><p>这种问题的漏洞在于，每个人都可以生成公钥私钥，但无法根据识别身份。这个时候，有一个第三方的权威机构，A向这家机构发动自己的公钥以及能够证明身份的信息（例如营业执照），完成自己在网络上的“实名认证”。这家权威机构在核实了A的信息和公钥之后，颁发给A一张数字证书，这家机构也叫数字证书颁发机构。有了权威机构的背书，任何人也无法冒充A了，因为现在人们获取公钥都直接从权威机构获取。</p><p>现在，A要向B发生信息，首先使用B的公钥加密原始信息，然后再用自己（A）的私钥再进行一道加密，这个过程就是数字签名。B收到加密信息后，首先向第三方权威机构获取A的公钥，然后使用A的公钥进行第一级解密，再用自己（B）的的私钥进行二级解密，就获取了原始信息。</p><p>数字证书颁发机构的作用就是完成公钥信息的“实名制”。</p><p>第一级加密和数字签名是对称的：</p><ul><li>第一级加密使用对方的公钥加密</li><li>第二级数字签名使用自己的私钥加密</li><li>收到信息后，首先向数字证书颁发机构获取发送方的公钥，完成数字签名信息的解密</li><li>然后使用自己的私钥解密出原始信息。</li></ul><p>总之，原始信息加密解密的方式是：接收的公钥加密，接收方的私钥解密。数字签名的加密解密方式是：发送方的私钥加密，发送到的公钥解密。</p><h2 id="ssh" tabindex="-1">ssh <a class="header-anchor" href="#ssh" aria-label="Permalink to &quot;ssh&quot;">​</a></h2><p>ssh命令用于登录远程主机</p><p>要登录远程主机，使用如下命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ssh  远程用户名@远程主机</span></span></code></pre></div><p>此时会提示你输入密码。</p><p>输入<code>exit</code>退出登录。</p><p>如果是第一次登录该远程主机，则默认会将远程主机的公钥追加到文件~/.ssh/known_hosts 的末尾。</p><h2 id="ssh-keygen" tabindex="-1">ssh-keygen <a class="header-anchor" href="#ssh-keygen" aria-label="Permalink to &quot;ssh-keygen&quot;">​</a></h2><p>ssh-keygen可以用了生成一对公私钥，运行命令后，会提示你：</p><ul><li>输入私钥的文件名，默认为id_rsa。如果已经有一个私钥而想增加一个，可以自定义一个名称。公钥的名称为<code>私钥名称.pub</code>。</li><li>公钥的密码，默认不设密码</li></ul><h2 id="ssh-copy-id" tabindex="-1">ssh-copy-id <a class="header-anchor" href="#ssh-copy-id" aria-label="Permalink to &quot;ssh-copy-id&quot;">​</a></h2><p>使用ssh-copy-id将客户端的公钥复制到远程主机的同名家目录的.ssh目录的 <code>authorized_keys</code> 文件中。以后就可以直接连接而不用输入密码了。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ssh-copy-id -i 公钥路径 远程用户名@远程主机地址</span></span></code></pre></div>',38),t=[p];function h(o,n,d,c,r,u){return e(),s("div",null,t)}const k=a(l,[["render",h]]);export{b as __pageData,k as default};
