import{_ as e,c as l,o as t,m as s}from"./chunks/framework.84TDCN6B.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Node.js/zx.js简介.md","filePath":"Node.js/zx.js简介.md"}'),o={name:"Node.js/zx.js简介.md"},n=s("p",null,"zx.js是google开源的一个github代码库，它的作用是将JavaScript和传统的shell命令相结合，使得开发者拥有更强大的操控能力。",-1),h=s("p",null,"先来简单介绍一下shell，shell 是一个用 C 语言编写的程序，bash是大多数Linux系统以及Mac OS X默认的shell，shell是用户和Linux之间的桥梁，它是一种命令式语言，当我们执行shell脚本的时候，可以打开终端，输入命令后回车执行，例如我们平时常用的cd mydir就是一条shell基础命令；同时它又是一种程序设计语言，可以以编程的方式来进行书写，它支持变量，数组，以及运算符操作等等，传统的shell脚本通常以.sh执行脚本文件结尾。 shell命令大家在日常开发中都会经常使用，比如进入目录，创建、移动、删除文件，查看文件夹内容、操作git命令等等，但是shell文件并不一定每个开发人员都写过，正是由于shell的语法特殊性使得它有一定的学习成本，苛刻的缩进规则和啰嗦的语法规则往往让编写shell头痛不已。",-1),c=s("p",null,"可能到这里一些前端开发工程师还不太理解为什么要用shell，前端开发明明都会写node，我们也经常使用node的基础模块来跟操作系统打交道啊，像我们平时用的fs模块，os模块都挺好用的。没错，虽然node为我们封装了一些控制操作系统的能力，比如child_process模块。使用child_process在JS文件中调用shell的方式需要写非常多的代码，这种侦听事件回调的调用方式使用起来非常割裂且繁琐。",-1),d=s("p",null,"如果不借助 zx.js 想尝试编写一个在 Node.js 下运行的 shell 脚本，可能会发现它并不像希望的那样流畅。需要为子进程编写特殊处理，注意转义命令行参数，然后使用标准输出 stdout 和标准错误 stderr，它不是特别直观，并且使用 shell 脚本编写变得非常笨拙。",-1),_=s("p",null,"zx.js的作者希望以更加友好的方式让前端工程师既能用JS方便的执行shell脚本。",-1),a=s("p",null,"需要说明的是，为了能够在zx语句中让await语法在顶层使用，需要创建.mjs为扩展名的文件，它代表zx的可执行脚本文件。",-1),i=s("p",null,"zx.js提供了一些全局函数，如$，cd，fetch等，且无需导入；",-1),r=[n,h,c,d,_,a,i];function p(u,x,j,m,f,z){return t(),l("div",null,r)}const S=e(o,[["render",p]]);export{g as __pageData,S as default};
