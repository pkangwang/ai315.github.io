import{_ as l,c as i,o as t,a2 as e}from"./chunks/framework.84TDCN6B.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"TechBookCatalog/流畅的Python.md","filePath":"TechBookCatalog/流畅的Python.md"}'),o={name:"TechBookCatalog/流畅的Python.md"},a=e('<p><img src="https://m.360buyimg.com/mobilecms/s750x750_jfs/t1/165613/29/35883/68027/642be78eFf02f7086/9310a1691fd0e8b8.jpg!q80.dpg.webp" alt=""></p><p>【第一部分 数据结构】</p><ul><li>第1章 Python数据类型 <ul><li>1.1 本章新增内容</li><li>1.2 一摞Python风格的纸牌</li><li>1.3 特殊方法是如何使用的</li><li>1.4 特殊方法概述</li><li>1.5 len为什么不是方法</li></ul></li><li>第2章 丰富的序列 <ul><li>2.1 本章新增内容</li><li>2.2 内置序列类型概览</li><li>2.3 列表推导式和生成器表达式</li><li>2.4 元组不仅仅是不可变列表</li><li>2.5 序列和可迭代对象拆包</li><li>2.6 序列模式匹配</li><li>2.7 切片</li><li>2.8 使用 + 和 * 处理序列</li><li>2.9 list.sort 与内置函数sorted</li><li>2.10 当列表不适用时</li></ul></li><li>第3章 字典和集合 <ul><li>3.1 本章新增内容</li><li>3.2 字典的现代方法</li><li>3.3 使用模式匹配处理映射</li><li>3.4 映射类型的标准API</li><li>3.5 自动处理缺失的键</li><li>3.6 dict 的变体</li><li>3.7 不可变映射</li><li>3.8 字典视图</li><li>3.9 dict 的实现方式对实践的影响</li><li>3.10 集合论</li><li>3.11 集合的实现方式对实践的影响</li><li>3.12 字典视图的集合运算</li></ul></li><li>第4章 Unicode文本和字节序列 <ul><li>4.1 本章新增内容</li><li>4.2 字符问题</li><li>4.3 字节概要</li><li>4.4 基本的编码解码器</li><li>4.5 处理编码和解码问题</li><li>4.6 处理文本文件</li><li>4.7 为了正确比较而规范化Unicode字符串</li><li>4.8 Unicode文本排序</li><li>4.9 Unicode数据库</li><li>4.10 支持 str 和 bytes 的双模式API</li></ul></li><li>第5章 数据类构建器 <ul><li>5.1 本章新增内容</li><li>5.2 数据类构建器概述</li><li>5.3 典型的具名元组</li><li>5.4 带类型的具名元组</li><li>5.5 类型提示入门</li><li>5.6 @dataclass详解</li><li>5.7 数据类导致代码异味</li><li>5.8 模式匹配类实例</li></ul></li><li>第6章 对象引用、可变性和垃圾回收 <ul><li>6.1 本章新增内容</li><li>6.2 变量不是盒子</li><li>6.3 同一性、相等性和别名</li><li>6.4 默认做浅拷贝</li><li>6.5 函数的参数是引用时</li><li>6.6 del 和垃圾回收</li><li>6.7 Python对不可变类型施加的把戏</li></ul></li></ul>',3),s=[a];function c(_,n,d,r,u,p){return t(),i("div",null,s)}const P=l(o,[["render",c]]);export{m as __pageData,P as default};
