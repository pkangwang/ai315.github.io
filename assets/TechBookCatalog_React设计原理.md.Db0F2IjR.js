import{_ as l,c as i,o as e,a2 as u}from"./chunks/framework.84TDCN6B.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"TechBookCatalog/React设计原理.md","filePath":"TechBookCatalog/React设计原理.md"}'),t={name:"TechBookCatalog/React设计原理.md"},a=u('<p><img src="https://m.360buyimg.com/mobilecms/s750x750_jfs/t1/93803/32/16980/57706/63870823E9dc6d788/e8b32f7911a709e4.jpg!q80.dpg.webp" alt=""></p><p>【第1篇 理念篇】</p><ul><li>第1章 前端框架原理概览 <ul><li>1.1 初识前端框架 <ul><li>1.1.1 如何描述UI</li><li>1.1.2 如何组织UI与逻辑</li><li>1.1.3 如何在组件之间传输数据</li><li>1.1.4 前端框架的分类依据</li><li>1.1.5 React 中的自变量与因变量</li></ul></li><li>1.2 前端框架使用的技术 <ul><li>1.2.1 编程: 细粒度更新</li><li>1.2.2 AOT</li><li>1.2.3 Virtual DOM</li></ul></li><li>1.3 前端框架的实现原理 <ul><li>1.3.1 Svelte</li><li>1.3.2 Vue3</li><li>1.3.3 React</li></ul></li><li>1.4 总结</li></ul></li><li>第2章 React 理念 <ul><li>2.1 问题与解决思路 <ul><li>2.1.1 事件循环</li><li>2.1.2 浏览器渲染</li><li>2.1.3 CPU瓶颈</li><li>2.1.4 I/O瓶颈</li></ul></li><li>2.2 底层架构的演进 <ul><li>2.2.1 新旧架构介绍</li><li>2.2.2 主打特性的迭代</li><li>2.2.3 渐进升级策略的迭代</li></ul></li><li>2.3 Fiber 架构 <ul><li>2.3.1 FiberNode的含义</li><li>2.3.2 双缓存机制</li><li>2.3.3 mount 时Fiber Tree的构建</li><li>2.3.4 update 时Fiber Tree的构建</li></ul></li><li>2.4 调试React源码 <ul><li>2.4.1 仓库结构概览</li><li>2.4.2 以本书推荐方式调试源码</li><li>2.4.3 以官方方式调试源码</li></ul></li><li>2.5 总结</li></ul></li></ul><p>【第2篇 架构篇】</p><ul><li>第3章 render 阶段 <ul><li>3.1 流程概览</li><li>3.2 beginWork</li><li>3.3 React 中的位运算 <ul><li>3.3.1 基本的三种位运算</li><li>3.3.2 位运算在“标记状态”中的应用</li></ul></li><li>3.4 completeWork <ul><li>3.4.1 flags冒泡</li><li>3.4.2 mount概览</li><li>3.4.3 update概览</li></ul></li><li>3.5 编程: ReactDOM Renderer</li><li>3.6 总结</li></ul></li><li>第4章 commit 阶段 <ul><li>4.1 流畅概览 <ul><li>4.1.1 子阶段的执行流程</li><li>4.1.2 Effects list</li></ul></li><li>4.2 错误处理 <ul><li>4.2.1 捕获错误</li><li>4.2.2 构造callback</li><li>4.2.3 执行callback</li></ul></li><li>4.3 BeforeMutation 阶段</li><li>4.4 Mutation 阶段 <ul><li>4.4.1 删除DOM 元素</li><li>4.4.2 插入、移动DOM元素</li><li>4.4.3 更新DOM元素</li><li>4.4.4 Fiber Tree切换</li></ul></li><li>4.5 Layout 阶段</li><li>4.6 总结</li></ul></li><li>第5章 schedule 阶段 <ul><li>5.1 编程: 建议schedule 阶段实现 <ul><li>5.1.1 Scheduler 简介</li><li>5.1.2 改造后的schedule 方法</li><li>5.1.3 改造后的perform 方法</li><li>5.1.4 改造后的完整流程</li></ul></li><li>5.2 Scheduler 的实现 <ul><li>5.2.1 流程概览</li><li>5.2.2 优先级队列的实现</li><li>5.2.3 宏任务的选择</li></ul></li><li>5.3 Lane 模型 <ul><li>5.3.1 React 与 Scheduler的结合</li><li>5.3.2 基于expirationTime的算法</li><li>5.3.3 基于Lane 的算法</li></ul></li><li>5.4 Lane 模型在React 中的应用 <ul><li>5.4.1 初始化lane</li><li>5.4.2 从fiberNode 到FiberRootNode</li><li>5.4.3 调度FiberRootNode</li><li>5.4.4 调度策略</li><li>5.4.5 解决饥饿问题</li><li>5.4.6 root.pendingLanes工作流畅</li></ul></li><li>5.5 Batched Updates <ul><li>5.5.1 Batched Updates</li><li>5.5.2 不同框架Batched Updates的区别</li></ul></li><li>5.6 总结</li></ul></li></ul><p>【第3篇 实现篇】</p><ul><li>第6章 状态更新流畅 <ul><li>6.1 编程: 简易事件系统实现 <ul><li>6.1.1 实现SyntheticEvent</li><li>6.1.2 实现事件传播机制</li><li>6.1.3 收集路径中的事件回调函数</li><li>6.1.4 捕获、冒泡阶段的实现</li></ul></li><li>6.2 Update <ul><li>6.2.1 心智模型</li><li>6.2.2 数据结构</li><li>6.2.3 updateQueue</li><li>6.2.4 产生update</li><li>6.2.5 消费update需要考虑的问题</li><li>6.2.6 消费update</li></ul></li><li>6.3 ReactDOM.createRoot 流程</li><li>6.4 useState 流程</li><li>6.5 性能优化 <ul><li>6.5.1 eagerState 策略</li><li>6.5.2 bailout 策略</li><li>6.5.3 bailout 策略的示例</li><li>6.5.4 bailout 与Context API</li><li>6.5.5 对日常开发的启示</li></ul></li><li>6.6 总结</li></ul></li><li>第7章 reconcile 流程 <ul><li>7.1 单节点Diff</li><li>7.2 多节点Diff <ul><li>7.2.1 设计思路</li><li>7.2.2 算法实现</li></ul></li><li>7.3 编程: 实现Diff 算法 <ul><li>7.3.1 遍历前的准备工作</li><li>7.3.2 核心遍历逻辑</li><li>7.3.3 遍历后的收尾工作</li></ul></li><li>7.4 总结</li></ul></li><li>第8章 FC 与Hooks 实现 <ul><li>8.1 心智模型 <ul><li>8.1.1 代数效应</li><li>8.1.2 FC 与Suspense</li><li>8.1.3 Suspense 工作流程</li></ul></li><li>8.2 编程: 简易useState 实现 <ul><li>8.2.1 实现“产生更新的流程”</li><li>8.2.2 实现useState</li><li>8.2.3 简易实现的不足</li></ul></li><li>8.3 Hooks 流程概览 <ul><li>8.3.1 dispatcher</li><li>8.3.2 Hooks 的数据结构</li><li>8.3.3 Hooks 执行流程</li></ul></li><li>8.4 useState与useReducer</li><li>8.5 effect 相关Hook <ul><li>8.5.1 数据结构</li><li>8.5.2 声明阶段</li><li>8.5.3 调度阶段</li><li>8.5.4 执行阶段</li></ul></li><li>8.6 useMemo 与useCallback <ul><li>8.6.1 mount 时执行流程</li><li>8.6.2 update 时执行流程</li><li>8.6.3 useMemo 的妙用</li></ul></li><li>8.7 useRef 312 <ul><li>8.7.1 实现原理 313</li><li>8.7.2 ref的工作流程 314</li><li>8.7.3 ref的失控 317</li><li>8.7.4 ref失控的防治 318</li></ul></li><li>8.8 useTransition 321 <ul><li>8.8.1 useTransition实现原理 322</li><li>8.8.2 useTransition工作流程 324</li><li>8.8.3 entangle机制 326</li><li>8.8.4 entangle实现原理 327</li><li>8.8.5 entangle工作流程 328</li></ul></li><li>8.9 useDeferredValue 333</li><li>8.10 编程：实现useErrorBoundary 336 <ul><li>8.10.1 定义dispatcher 338</li><li>8.10.2 实现逻辑 339</li><li>8.10.3 提取公共方法 342</li><li>8.10.4 render阶段错误处理流程 343</li><li>8.10.5 commit阶段错误处理流程 349</li></ul></li><li>8.11 总结 351</li></ul></li></ul>',7),o=[a];function r(c,s,n,d,p,_){return e(),i("div",null,o)}const h=l(t,[["render",r]]);export{m as __pageData,h as default};
